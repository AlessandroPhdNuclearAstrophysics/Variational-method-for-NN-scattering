MODULE QUANTUM_NUMBERS
  IMPLICIT NONE

  TYPE, PUBLIC :: SCATTERING_CHANNEL
    INTEGER, PRIVATE :: J
    INTEGER, ALLOCATABLE, PRIVATE :: L(:)
    INTEGER, ALLOCATABLE, PRIVATE :: S(:)
    INTEGER, ALLOCATABLE, PRIVATE :: T(:)
    INTEGER, PRIVATE :: TZ
    INTEGER, PRIVATE :: NCH
  ENDTYPE SCATTERING_CHANNEL 

  INTERFACE GET_CHANNEL_NAME
    MODULE PROCEDURE GET_CHANNEL_NAME_LSJ
    MODULE PROCEDURE GET_CHANNEL_NAME_FROM_OBJECT
  END INTERFACE GET_CHANNEL_NAME

CONTAINS
  ! Constructor for SCATTERING_CHANNEL
  FUNCTION init_scattering_channel(J, IS_EVEN, TZ) RESULT(channel)
    INTEGER, INTENT(IN) :: J, TZ
    LOGICAL, INTENT(IN) :: IS_EVEN
    TYPE(SCATTERING_CHANNEL) :: CHANNEL

    INTEGER :: ICH

    IF (J == 0) THEN
      CHANNEL%NCH = 1
    ELSE
      CHANNEL%NCH = 2
    ENDIF

    ! ALLOCATE ARRAYS FOR L AND S
    ALLOCATE(CHANNEL%L(CHANNEL%NCH))
    ALLOCATE(CHANNEL%S(CHANNEL%NCH))
    ALLOCATE(CHANNEL%T(CHANNEL%NCH))
    IF (J == 0) THEN
      IF (IS_EVEN) THEN
        CHANNEL%L(1) = 0
        CHANNEL%S(1) = 0
      ELSE
        CHANNEL%L(1) = 1
        CHANNEL%S(1) = 1
      ENDIF
    ELSE
      IF (MOD(J, 2) == 0) THEN
        IF (IS_EVEN) THEN
          CHANNEL%L(1) = J
          CHANNEL%S(1) = 0
          CHANNEL%L(2) = J
          CHANNEL%S(2) = 1
        ELSE
          CHANNEL%L(1) = J-1
          CHANNEL%S(1) = 1
          CHANNEL%L(2) = J+1
          CHANNEL%S(2) = 1
        ENDIF
      ELSE
        IF (IS_EVEN) THEN
          CHANNEL%L(1) = J - 1
          CHANNEL%S(1) = 1
          CHANNEL%L(2) = J + 1
          CHANNEL%S(2) = 1
        ELSE
          CHANNEL%L(1) = J
          CHANNEL%S(1) = 0
          CHANNEL%L(2) = J
          CHANNEL%S(2) = 1
        ENDIF
      ENDIF
    ENDIF

    CHANNEL%J = J
    DO ICH = 1, CHANNEL%NCH
      CHANNEL%T(ICH) = EVALUATE_T(CHANNEL%L(ICH), CHANNEL%S(ICH), TZ)
    ENDDO
    CHANNEL%TZ = TZ
  END FUNCTION init_scattering_channel

  FUNCTION EVALUATE_T(L, S, TZ) RESULT(T)
    INTEGER, INTENT(IN) :: L, S, TZ
    INTEGER :: T

    ! Calculate T based on the values of J, L, S, and TZ
    T = MOD( MOD(L+S, 2) + 1 , 2)
    IF (ABS(TZ) > T) THEN
      PRINT *, "Error: Invalid value for TZ. It must be less than or equal to T."
      STOP
    ENDIF
  END FUNCTION EVALUATE_T

  FUNCTION IS_PHYSICAL_CHANNEL(CHANNEL) RESULT(IS_PHYSICAL)
    TYPE(SCATTERING_CHANNEL), INTENT(IN) :: CHANNEL
    LOGICAL :: IS_PHYSICAL
    INTEGER :: L, S, J, T, ICH
    
    J = CHANNEL%J
    IS_PHYSICAL = .TRUE.

    DO ICH=1, CHANNEL%NCH
      L = CHANNEL%L(ICH)
      S = CHANNEL%S(ICH)
      T = CHANNEL%T(ICH)

      ! CHECK IF THE SCATTERING CHANNEL IS PHYSICAL
      IS_PHYSICAL = IS_PHYSICAL .AND. (J >= 0 .AND. L >= 0 .AND. S >= 0 .AND. T >= 0)
      IF (IS_PHYSICAL) THEN
        IS_PHYSICAL = IS_PHYSICAL .AND. IS_LSJ_PHYSICAL(L, S, J)
      ENDIF
    ENDDO
  END FUNCTION IS_PHYSICAL_CHANNEL

  FUNCTION IS_LSJ_PHYSICAL(L, S, J) RESULT(IS_LSJ)
    INTEGER, INTENT(IN) :: L, S, J
    LOGICAL :: IS_LSJ
    IS_LSJ = ABS(L-S) <= J .AND. J <= (L+S)
  END FUNCTION IS_LSJ_PHYSICAL

  SUBROUTINE SET_CHANNEL(CHANNEL, J, L, S, TZ)
    TYPE(SCATTERING_CHANNEL), INTENT(INOUT) :: CHANNEL
    INTEGER, INTENT(IN) :: J, L, S, TZ
    LOGICAL :: IS_EVEN

    IF (IS_LSJ_PHYSICAL(L, S, J)) THEN
      PRINT *, "Error: Invalid values for L, S, and J."
      STOP
    ENDIF
    IS_EVEN = MOD(L, 2) == 0

    IF (J == 0) THEN
      CHANNEL%NCH = 1
      ALLOCATE(CHANNEL%L(1), CHANNEL%S(1), CHANNEL%T(1))
      CHANNEL%L(1) = L
      CHANNEL%S(1) = S
      CHANNEL%T(1) = EVALUATE_T(L, S, TZ)
    ELSE
      IF ((L.EQ.(J-1) .OR. L.EQ.(J+1))) THEN
        CHANNEL%NCH = 2
        ALLOCATE(CHANNEL%L(2), CHANNEL%S(2), CHANNEL%T(2))
        CHANNEL%L(1) = J-1
        CHANNEL%S(1) = S
        CHANNEL%L(2) = J+1
        CHANNEL%S(2) = S
        CHANNEL%T(1) = EVALUATE_T(J-1, S, TZ)
        CHANNEL%T(2) = EVALUATE_T(J+1, S, TZ)
      ELSE
        CHANNEL%NCH = 1
        ALLOCATE(CHANNEL%L(1), CHANNEL%S(1), CHANNEL%T(1))
        CHANNEL%L(1) = J
        CHANNEL%S(1) = S
        CHANNEL%T(1) = EVALUATE_T(J, S, TZ)
      ENDIF
    ENDIF
  END SUBROUTINE SET_CHANNEL  

  FUNCTION GET_CHANNEL_NAME_LSJ(L, S, J) RESULT(NAME)
    INTEGER, INTENT(IN) :: L, S, J
    CHARACTER(LEN=3) :: NAME

    ! Generate a name for the scattering channel based on L, S, and J
    ! Format: '<2S+1><L_letter><J>', e.g., '3SD' for S=1, L=2, J=2

    NAME = '   '
    SELECT CASE (L)
      CASE (0)
        NAME(2:2) = 'S'
      CASE (1)
        NAME(2:2) = 'P'
      CASE (2)
        NAME(2:2) = 'D'
      CASE (3)
        NAME(2:2) = 'F'
      CASE DEFAULT
        ! Map L >= 4 to corresponding spectroscopic letter (G=4, H=5, I=6, etc.)
        NAME(2:2) = CHAR(71 + (L-4))  ! 71 is ASCII for 'G'
    END SELECT

    WRITE(NAME(1:1), '(I1)') 2*S+1
    WRITE(NAME(3:3), '(I1)') J
  END FUNCTION GET_CHANNEL_NAME_LSJ

  FUNCTION GET_CHANNEL_NAME_FROM_OBJECT(CHANNEL) RESULT(NAME)
    TYPE(SCATTERING_CHANNEL), INTENT(IN) :: CHANNEL
    CHARACTER(LEN=16) :: NAME
    INTEGER :: ICH

    ICH = 1
    NAME = GET_CHANNEL_NAME_LSJ(CHANNEL%L(ICH), CHANNEL%S(ICH), CHANNEL%J)
    DO ICH = 2, CHANNEL%NCH
      NAME = TRIM(NAME) // "-" // GET_CHANNEL_NAME_LSJ(CHANNEL%L(ICH), CHANNEL%S(ICH), CHANNEL%J)
    ENDDO
  END FUNCTION GET_CHANNEL_NAME_FROM_OBJECT
  

END MODULE QUANTUM_NUMBERS