#!/usr/bin/env python3
"""
Dependency Tree Visualizer

This script visualizes module dependencies as a tree diagram.
It parses dependency information from Fortran module dependencies
generated by scan_deps.py and creates both text and graphical representations.
"""

import sys
import re
import os
from collections import defaultdict
import matplotlib.pyplot as plt
import networkx as nx
from pathlib import Path
import argparse
from matplotlib.cm import get_cmap
import math
from networkx.drawing.nx_agraph import graphviz_layout
import numpy as np

def find_dependency_files(dep_dir):
    """Find all .d dependency files in the specified directory."""
    dep_path = Path(dep_dir)
    if not dep_path.exists():
        print(f"Error: Dependency directory not found: {dep_dir}")
        sys.exit(1)
    
    # Find all .d files recursively
    return list(dep_path.rglob("*.d"))

def parse_fortran_dependencies(dep_files):
    """Parse Fortran dependency files generated by scan_deps.py."""
    dependencies = defaultdict(list)
    main_programs = []
    
    for dep_file in dep_files:
        try:
            with open(dep_file, 'r') as f:
                content = f.read().strip()
                
                # Skip empty files
                if not content:
                    continue
                
                # Check if this is a main program
                is_main = False
                if "# MAIN_PROGRAM: True" in content:
                    is_main = True
                
                # Parse Make-style dependencies: target: dependency1 dependency2
                lines = content.split('\n')
                main_line = lines[0]
                
                # Skip lines without dependencies
                if ':' not in main_line:
                    continue
                
                target, deps_str = main_line.split(':', 1)
                target = Path(target.strip()).stem  # Get base name without extension
                
                # Get dependencies
                deps = deps_str.strip().split()
                clean_deps = []
                for dep in deps:
                    # Get base name without extension and path
                    dep_name = Path(dep.strip()).stem
                    if dep_name and dep_name != target:  # Avoid self-dependencies
                        clean_deps.append(dep_name)
                
                if clean_deps:
                    dependencies[target].extend(clean_deps)
                
                # Add to main programs list if this is a main program
                if is_main:
                    main_programs.append(target)
                
                # Check for missing modules comments
                for line in lines[1:]:
                    if line.startswith('# Missing module:'):
                        missing_mod = line.replace('# Missing module:', '').strip()
                        if missing_mod:
                            dependencies[target].append(missing_mod)
        
        except Exception as e:
            print(f"Error parsing {dep_file}: {e}")
    
    return dependencies, main_programs

def get_recursive_dependencies(module, dependencies, visited=None):
    """Get all dependencies recursively for a module, including indirect ones."""
    if visited is None:
        visited = set()
    
    if module in visited:
        return set()  # Avoid cycles
    
    visited.add(module)
    all_deps = set(dependencies.get(module, []))
    
    for dep in dependencies.get(module, []):
        all_deps.update(get_recursive_dependencies(dep, dependencies, visited.copy()))
    
    return all_deps

def extract_program_subgraph(G, main_program, dependencies):
    """Extract a subgraph containing only the main program and its dependencies."""
    # Get all recursive dependencies for the main program
    all_deps = get_recursive_dependencies(main_program, dependencies)
    all_deps.add(main_program)
    
    # Create subgraph with only relevant nodes
    return G.subgraph(all_deps)

def build_tree(dependencies):
    """Build a tree structure from the dependencies."""
    tree = {}
    for module in dependencies:
        tree[module] = get_dependencies_recursive(module, dependencies, set())
    
    return tree

def get_dependencies_recursive(module, dependencies, visited):
    """Recursively get all dependencies for a module."""
    if module in visited:
        return {}  # Avoid cycles
    
    visited.add(module)
    subtree = {}
    
    for dep in dependencies.get(module, []):
        subtree[dep] = get_dependencies_recursive(dep, dependencies, visited.copy())
    
    return subtree

def build_graph(dependencies):
    """Build a directed graph from the dependencies."""
    G = nx.DiGraph()
    
    # Add all modules as nodes
    for module in dependencies:
        G.add_node(module)
        for dep in dependencies[module]:
            G.add_node(dep)
            G.add_edge(module, dep)
    
    return G

def group_by_prefix(G, num_chars=1):
    """Group nodes by common prefixes to reduce visual complexity."""
    prefix_groups = defaultdict(list)
    
    for node in G.nodes():
        # Use first num_chars characters as the prefix
        if len(node) >= num_chars:
            prefix = node[:num_chars]
            prefix_groups[prefix].append(node)
        else:
            # If node name is shorter than num_chars, use the whole name
            prefix_groups[node].append(node)
    
    return prefix_groups

def get_graph_stats(G):
    """Calculate graph statistics to inform layout decisions."""
    stats = {
        'nodes': len(G.nodes()),
        'edges': len(G.edges()),
        'density': nx.density(G),
        'avg_degree': sum(dict(G.degree()).values()) / max(1, len(G.nodes())),
        'max_degree': max(dict(G.degree()).values()) if G.nodes() else 0,
        'components': nx.number_connected_components(G.to_undirected()),
        'diameter': nx.diameter(max(nx.connected_component_subgraphs(G.to_undirected()), 
                                   key=len)) if G.nodes() else 0
    }
    return stats

def optimize_layout_params(G):
    """Optimize layout parameters based on graph characteristics."""
    stats = get_graph_stats(G)
    params = {}
    
    # Adjust node spacing based on graph density
    if stats['density'] < 0.05:
        params['k'] = 2.0  # More spread out for sparse graphs
    elif stats['density'] > 0.2:
        params['k'] = 0.8  # More compact for dense graphs
    else:
        params['k'] = 1.5  # Default
    
    # Adjust iterations based on graph size
    if stats['nodes'] < 20:
        params['iterations'] = 50
    elif stats['nodes'] > 100:
        params['iterations'] = 200
    else:
        params['iterations'] = 100
    
    return params

def partition_large_graph(G, max_nodes_per_graph=50):
    """Split large graphs into smaller, more manageable subgraphs."""
    if len(G.nodes()) <= max_nodes_per_graph:
        return [G]
    
    # Use community detection to partition the graph
    try:
        import community as community_louvain
        undirected_G = G.to_undirected()
        partition = community_louvain.best_partition(undirected_G)
        
        # Group nodes by community
        communities = defaultdict(list)
        for node, community_id in partition.items():
            communities[community_id].append(node)
        
        # Create subgraphs
        subgraphs = []
        for community_nodes in communities.values():
            if len(community_nodes) > max_nodes_per_graph:
                # Further partition large communities
                large_community = G.subgraph(community_nodes)
                subgraphs.extend(partition_large_graph(large_community, max_nodes_per_graph))
            else:
                subgraphs.append(G.subgraph(community_nodes))
        
        return subgraphs
    except ImportError:
        # Fall back to a simpler partitioning method if community module is not available
        sorted_nodes = sorted(G.nodes(), key=lambda n: G.degree(n), reverse=True)
        return [G.subgraph(sorted_nodes[i:i+max_nodes_per_graph]) 
                for i in range(0, len(sorted_nodes), max_nodes_per_graph)]

def apply_edge_bundling(G, pos, compatibility_threshold=0.6):
    """Apply edge bundling to reduce visual clutter."""
    bundled_edges = defaultdict(list)
    
    # Calculate edge compatibility
    for e1 in G.edges():
        for e2 in G.edges():
            if e1 >= e2:  # Avoid duplicate checks
                continue
                
            # Simple compatibility measure - edges with similar directions
            src1, tgt1 = e1
            src2, tgt2 = e2
            
            # Get positions
            p_src1, p_tgt1 = pos[src1], pos[tgt1]
            p_src2, p_tgt2 = pos[src2], pos[tgt2]
            
            # Calculate directions
            dir1 = np.array(p_tgt1) - np.array(p_src1)
            dir2 = np.array(p_tgt2) - np.array(p_src2)
            
            # Normalize
            len1 = np.linalg.norm(dir1)
            len2 = np.linalg.norm(dir2)
            if len1 > 0 and len2 > 0:
                dir1 = dir1 / len1
                dir2 = dir2 / len2
                
                # Angle between directions
                cos_angle = np.dot(dir1, dir2)
                
                if cos_angle > compatibility_threshold:
                    key = tuple(sorted([e1, e2]))
                    bundled_edges[key].extend([e1, e2])
    
    return bundled_edges

def visualize_graph(G, output_file='fortran_dependency_tree.png', layout='hierarchical', 
                    filter_isolated=True, group_nodes=False, group_prefix_length=1,
                    node_size_factor=100, edge_width=1.0, title=None, 
                    max_nodes_per_graph=100, adjust_layout=True, use_edge_bundling=False,
                    remove_transitive=False):
    """
    Visualize the dependency graph using matplotlib with improved layout.
    
    Parameters:
    - layout: Layout algorithm ('hierarchical', 'circular', 'spring', 'spectral')
    - filter_isolated: Whether to filter out isolated nodes with no connections
    - group_nodes: Whether to group nodes by common prefixes
    - group_prefix_length: Number of characters to use for grouping by prefix
    - node_size_factor: Factor to adjust node size (smaller values = smaller nodes)
    - edge_width: Width of the edges
    - title: Custom title for the graph
    - max_nodes_per_graph: Maximum number of nodes per graph; if exceeded, split into multiple graphs
    - adjust_layout: Whether to automatically adjust layout parameters based on graph characteristics
    - use_edge_bundling: Whether to use edge bundling to reduce visual clutter
    - remove_transitive: Whether to remove transitive dependencies to simplify the graph
    """
    # Remove transitive edges if requested
    if remove_transitive:
        transitive_closure = nx.transitive_closure(G)
        transitive_edges = set(transitive_closure.edges()) - set(G.edges())
        for edge in transitive_edges:
            if G.has_edge(*edge):
                G.remove_edge(*edge)
    
    # Filter isolated nodes if requested
    if filter_isolated:
        # Keep only nodes with at least one connection
        nodes_to_keep = [node for node in G.nodes() if G.degree(node) > 0]
        G = G.subgraph(nodes_to_keep)
    
    # If graph is too large, partition it
    if len(G.nodes()) > max_nodes_per_graph:
        subgraphs = partition_large_graph(G, max_nodes_per_graph)
        print(f"Graph partitioned into {len(subgraphs)} subgraphs")
        
        # Generate a visualization for each subgraph
        for i, subgraph in enumerate(subgraphs):
            subgraph_output = output_file.replace('.png', f'_part{i+1}.png')
            subgraph_title = f"{title} (Part {i+1})" if title else f"Module Dependencies (Part {i+1})"
            
            # Recursively call visualize_graph for each subgraph
            visualize_graph(
                subgraph, 
                output_file=subgraph_output,
                layout=layout,
                filter_isolated=False,  # Already filtered
                group_nodes=group_nodes,
                group_prefix_length=group_prefix_length,
                node_size_factor=node_size_factor,
                edge_width=edge_width,
                title=subgraph_title,
                max_nodes_per_graph=max_nodes_per_graph,
                adjust_layout=adjust_layout,
                use_edge_bundling=use_edge_bundling,
                remove_transitive=False  # Already processed
            )
        
        # Create an overview graph showing connections between parts
        # (this is beyond the scope of this response)
        
        return
    
    # Optimize figure size based on node count
    node_count = len(G.nodes())
    if node_count < 10:
        figsize = (10, 8)
    elif node_count < 30:
        figsize = (12, 10)
    elif node_count < 60:
        figsize = (15, 12)
    else:
        figsize = (20, 16)
    
    # Create figure with optimized size
    plt.figure(figsize=figsize, dpi=300)
    
    # Determine the layout based on user preference
    if layout == 'hierarchical':
        try:
            # Try different graphviz programs based on graph characteristics
            if node_count > 50:
                pos = graphviz_layout(G, prog='twopi')  # Radial layout for large graphs
            else:
                pos = graphviz_layout(G, prog='dot')  # Hierarchical for smaller graphs
        except Exception as e:
            print(f"Warning: Hierarchical layout failed ({str(e)}), falling back to spring layout")
            layout_params = optimize_layout_params(G) if adjust_layout else {'k': 0.3, 'iterations': 100}
            pos = nx.spring_layout(G, **layout_params)
    elif layout == 'circular':
        pos = nx.circular_layout(G)
    elif layout == 'spectral':
        pos = nx.spectral_layout(G)
    else:  # Default to spring layout
        layout_params = optimize_layout_params(G) if adjust_layout else {'k': 0.3, 'iterations': 100}
        pos = nx.spring_layout(G, **layout_params)
    
    # Apply edge bundling if requested
    bundled_edges = None
    if use_edge_bundling:
        bundled_edges = apply_edge_bundling(G, pos)
    
    # Calculate node sizes based on degree centrality and graph density
    # Adjust node size based on graph density - smaller nodes for denser graphs
    density_factor = 1.0 / (0.1 + nx.density(G)) if nx.density(G) > 0 else 10.0
    node_size_factor = min(100, node_size_factor * density_factor)
    
    node_degrees = dict(G.degree())
    node_sizes = [max(200, node_size_factor * (1 + node_degrees[node])) for node in G.nodes()]
    
    # For very large graphs, scale down all node sizes
    if node_count > 50:
        node_sizes = [size * (50 / node_count) for size in node_sizes]
    
    # Identify important nodes (high degree or centrality)
    centrality = nx.degree_centrality(G)
    node_colors = [centrality[node] for node in G.nodes()]
    
    # Group nodes by prefix if requested
    if group_nodes:
        prefix_groups = group_by_prefix(G, group_prefix_length)
        
        # Draw each group with a different color
        cmap = get_cmap('tab20')
        for i, (prefix, nodes) in enumerate(prefix_groups.items()):
            if len(nodes) > 1:  # Only process actual groups
                color = cmap(i % 20)  # Cycle through 20 distinct colors
                
                # Draw a background circle for the group
                x_avg = sum(pos[node][0] for node in nodes) / len(nodes)
                y_avg = sum(pos[node][1] for node in nodes) / len(nodes)
                
                # Calculate radius to encompass all nodes in the group
                radius = max(
                    max(abs(pos[node][0] - x_avg) for node in nodes),
                    max(abs(pos[node][1] - y_avg) for node in nodes)
                ) * 1.2  # Add 20% margin
                
                group_circle = plt.Circle((x_avg, y_avg), radius, 
                                        color=color, alpha=0.1, zorder=0)
                plt.gca().add_patch(group_circle)
                
                # Add group label
                plt.text(x_avg, y_avg + radius, f"Group: {prefix}*", 
                        fontsize=10, ha='center', va='bottom', 
                        bbox=dict(facecolor='white', alpha=0.7))
    
    # Draw edges with alpha transparency to reduce visual clutter
    if use_edge_bundling and bundled_edges:
        # Draw bundled edges
        for bundle in bundled_edges.values():
            # Use averaged control points for bundled edges
            pass  # Implementation of actual bundling would go here
    else:
        # Draw normal edges
        nx.draw_networkx_edges(
            G, pos, 
            width=edge_width,
            edge_color='gray', 
            alpha=0.6,
            arrows=True, 
            arrowstyle='->', 
            arrowsize=10,
            connectionstyle='arc3,rad=0.1'  # Curved edges to reduce overlap
        )
    
    # Draw nodes with a colormap based on centrality
    nodes = nx.draw_networkx_nodes(
        G, pos,
        node_size=node_sizes,
        node_color=node_colors,
        cmap=plt.cm.viridis,
        alpha=0.8
    )
    
    # Add a colorbar to indicate connectivity
    plt.colorbar(nodes, label='Connectivity (Degree Centrality)')
    
    # For dense graphs, adjust label size and positioning
    label_size = 10 if node_count < 30 else 8 if node_count < 60 else 6
    
    # Draw labels with improved readability
    nx.draw_networkx_labels(
        G, pos,
        font_size=label_size,
        font_family='sans-serif',
        font_weight='bold',
        bbox=dict(facecolor='white', edgecolor='none', alpha=0.7, pad=1)
    )
    
    # Set title
    if title:
        plt.title(title, size=16)
    else:
        plt.title('Fortran Module Dependencies', size=16)
    
    plt.axis('off')
    
    # Adjust figure margins to maximize space
    plt.tight_layout()
    
    # Save the figure with high quality
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    print(f"Dependency graph visualization saved as {output_file}")
    
    # Close the figure to free memory
    plt.close()

def print_tree(dependencies, module=None, indent=0, visited=None):
    """Print a text-based tree visualization of the dependencies."""
    if visited is None:
        visited = set()
    
    if module is None:
        # Print tree for each module that has dependencies
        for root in sorted(dependencies.keys()):
            print(f"{root}")
            print_tree(dependencies, root, indent=1, visited=set())
    else:
        # Check for cycles
        if module in visited:
            print(f"{' ' * indent * 4}└── {module} (circular dependency)")
            return
        
        visited.add(module)
        
        # Print dependencies
        for i, dep in enumerate(sorted(dependencies.get(module, []))):
            is_last = i == len(dependencies.get(module, [])) - 1
            prefix = "└── " if is_last else "├── "
            print(f"{' ' * indent * 4}{prefix}{dep}")
            
            # Recursive call for nested dependencies
            if dep in dependencies:
                print_tree(dependencies, dep, indent + 1, visited.copy())

def main():
    """Main function to run the script."""
    parser = argparse.ArgumentParser(
        description='Generate a dependency tree visualization for Fortran modules.')
    
    parser.add_argument('dep_directory', 
                      help='Directory containing .d dependency files (typically build/dep)')
    
    parser.add_argument('-o', '--output', default='fortran_dependency_tree.png',
                      help='Output filename for the dependency graph')
    
    parser.add_argument('-l', '--layout', default='hierarchical', 
                      choices=['hierarchical', 'circular', 'spring', 'spectral'],
                      help='Layout algorithm for the graph')
    
    parser.add_argument('-f', '--filter-isolated', action='store_true',
                      help='Filter out isolated nodes with no connections')
    
    parser.add_argument('-g', '--group-nodes', action='store_true',
                      help='Group nodes by common prefixes')
    
    parser.add_argument('-p', '--prefix-length', type=int, default=1,
                      help='Number of characters to use for grouping by prefix')
    
    parser.add_argument('-s', '--node-size', type=float, default=100,
                      help='Factor to adjust node size (smaller values = smaller nodes)')
    
    parser.add_argument('-w', '--edge-width', type=float, default=1.0,
                      help='Width of the edges')
    
    parser.add_argument('-a', '--all-in-one', action='store_true',
                      help='Generate a single graph with all dependencies, in addition to per-program graphs')
    
    parser.add_argument('-d', '--output-dir', default='.',
                      help='Directory to save the dependency graphs')
    
    parser.add_argument('-m', '--max-nodes', type=int, default=100,
                      help='Maximum number of nodes per graph; larger graphs will be split')
    
    parser.add_argument('--auto-adjust', action='store_true',
                      help='Automatically adjust layout parameters based on graph characteristics')
    
    parser.add_argument('--edge-bundling', action='store_true',
                      help='Use edge bundling to reduce visual clutter')
    
    parser.add_argument('--remove-transitive', action='store_true',
                      help='Remove transitive dependencies to simplify the graph')
    
    args = parser.parse_args()
    
    # Find dependency files
    dep_files = find_dependency_files(args.dep_directory)
    if not dep_files:
        print(f"No dependency files found in {args.dep_directory}")
        sys.exit(1)
    
    print(f"Found {len(dep_files)} dependency files")
    
    # Parse dependencies and identify main programs
    dependencies, main_programs = parse_fortran_dependencies(dep_files)
    
    if not dependencies:
        print("No dependencies found in the parsed files")
        sys.exit(1)
    
    # Create output directory if it doesn't exist
    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Build the dependency graph
    G = build_graph(dependencies)
    
    # Generate a full dependency graph if requested
    if args.all_in_one:
        full_output = output_dir / args.output
        print(f"\nGenerating full dependency graph: {full_output}")
        visualize_graph(
            G, 
            output_file=str(full_output),
            layout=args.layout,
            filter_isolated=args.filter_isolated,
            group_nodes=args.group_nodes,
            group_prefix_length=args.prefix_length,
            node_size_factor=args.node_size,
            edge_width=args.edge_width,
            max_nodes_per_graph=args.max_nodes,
            adjust_layout=args.auto_adjust,
            use_edge_bundling=args.edge_bundling,
            remove_transitive=args.remove_transitive
        )
    
    # Generate separate graphs for each main program
    if main_programs:
        print(f"Found {len(main_programs)} main program files")
        for program in main_programs:
            # Extract subgraph for this program
            program_subgraph = extract_program_subgraph(G, program, dependencies)
            
            # Set output filename
            program_output = output_dir / f"{program}_dependencies.png"
            
            # Set graph title
            title = f"Dependencies for Program: {program}"
            
            print(f"Generating dependency graph for {program}")
            visualize_graph(
                program_subgraph,
                output_file=str(program_output),
                layout=args.layout,
                filter_isolated=args.filter_isolated,
                group_nodes=args.group_nodes,
                group_prefix_length=args.prefix_length,
                node_size_factor=args.node_size,
                edge_width=args.edge_width,
                title=title,
                max_nodes_per_graph=args.max_nodes,
                adjust_layout=args.auto_adjust,
                use_edge_bundling=args.edge_bundling,
                remove_transitive=args.remove_transitive
            )
    else:
        print("No main program files found. Only generating a full dependency graph.")
        full_output = output_dir / args.output
        visualize_graph(
            G, 
            output_file=str(full_output),
            layout=args.layout,
            filter_isolated=args.filter_isolated,
            group_nodes=args.group_nodes,
            group_prefix_length=args.prefix_length,
            node_size_factor=args.node_size,
            edge_width=args.edge_width,
            max_nodes_per_graph=args.max_nodes,
            adjust_layout=args.auto_adjust,
            use_edge_bundling=args.edge_bundling,
            remove_transitive=args.remove_transitive
        )
    
    print(f"\nDependency analysis complete. {len(dependencies)} modules analyzed.")

if __name__ == "__main__":
    main()
